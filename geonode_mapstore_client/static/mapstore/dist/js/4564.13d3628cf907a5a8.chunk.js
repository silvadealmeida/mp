(self.webpackChunkgeonode_mapstore_client=self.webpackChunkgeonode_mapstore_client||[]).push([[4564],{957043:(e,t,s)=>{var n=s(862488),r=s(121078),i=s(200278),o=s(701469);e.exports=function(){var e=arguments.length;if(!e)return[];for(var t=Array(e-1),s=arguments[0],h=e;h--;)t[h-1]=arguments[h];return n(o(s)?i(s):[s],r(t,1))}},406002:(e,t,s)=>{"use strict";s.d(t,{Z:()=>y});var n=s(542071),r=s(185487),i=s(914515),o=s(339781),h=s(922796),a=s(436885),l=s(928641),u=s(391900),g=s(302033),c=s(31660),_=s(974187),d=s(465818);function f(e){return e.feature?e.feature:e.element?e.element:null}const m=[];class p extends i.Z{constructor(e){const t=e=e||{};t.handleDownEvent||(t.handleDownEvent=a.uX),t.stopDown||(t.stopDown=a.Dv),super(t),this.source_=e.source?e.source:null,this.vertex_=void 0===e.vertex||e.vertex,this.edge_=void 0===e.edge||e.edge,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.rBush_=new o.Z,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=void 0===t||t;const s=(0,_.sq)(e),n=e.getGeometry();if(n){const t=this.GEOMETRY_SEGMENTERS_[n.getType()];if(t){this.indexedFeaturesExtents_[s]=n.getExtent((0,l.lJ)());const r=[];if(t(r,n),1===r.length)this.rBush_.insert((0,l.hI)(r[0]),{feature:e,segment:r[0]});else if(r.length>1){const t=r.map(e=>(0,l.hI)(e)),s=r.map(t=>({feature:e,segment:t}));this.rBush_.load(t,s)}}}t&&(this.featureChangeListenerKeys_[s]=(0,d.oL)(e,r.Z.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel),super.handleEvent(e)}handleFeatureAdd_(e){const t=f(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=f(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const e=(0,_.sq)(t);e in this.pendingFeatures_||(this.pendingFeatures_[e]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const s=void 0===t||t,n=(0,_.sq)(e),r=this.indexedFeaturesExtents_[n];if(r){const t=this.rBush_,s=[];t.forEachInExtent(r,function(t){e===t.feature&&s.push(t)});for(let e=s.length-1;e>=0;--e)t.remove(s[e])}s&&((0,d.bN)(this.featureChangeListenerKeys_[n]),delete this.featureChangeListenerKeys_[n])}setMap(e){const t=this.getMap(),s=this.featuresListenerKeys_,r=this.getFeatures_();t&&(s.forEach(d.bN),s.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(d.bN),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?s.push((0,d.oL)(this.features_,n.Z.ADD,this.handleFeatureAdd_,this),(0,d.oL)(this.features_,n.Z.REMOVE,this.handleFeatureRemove_,this)):this.source_&&s.push((0,d.oL)(this.source_,h.Z.ADDFEATURE,this.handleFeatureAdd_,this),(0,d.oL)(this.source_,h.Z.REMOVEFEATURE,this.handleFeatureRemove_,this)),r.forEach(e=>this.addFeature(e)))}snapTo(e,t,s){const n=s.getView().getProjection(),r=(0,c.Vs)(t,n),i=(0,c.Fj)((0,l.f3)((0,l.hI)([r]),s.getView().getResolution()*this.pixelTolerance_),n),o=this.rBush_.getInExtent(i),h=o.length;if(0===h)return null;let a,g=1/0;const _=this.pixelTolerance_*this.pixelTolerance_,d=()=>{if(a){const t=s.getPixelFromCoordinate(a);if((0,u.bI)(e,t)<=_)return{vertex:a,vertexPixel:[Math.round(t[0]),Math.round(t[1])]}}return null};if(this.vertex_){for(let e=0;e<h;++e){const t=o[e];"Circle"!==t.feature.getGeometry().getType()&&t.segment.forEach(e=>{const t=(0,c.Vs)(e,n),s=(0,u.bI)(r,t);s<g&&(a=e,g=s)})}const e=d();if(e)return e}if(this.edge_){for(let e=0;e<h;++e){let t=null;const s=o[e];if("Circle"===s.feature.getGeometry().getType()){let e=s.feature.getGeometry();const i=(0,c.Cs)();i&&(e=e.clone().transform(i,n)),t=(0,u.Ed)(r,e)}else{const[e,i]=s.segment;i&&(m[0]=(0,c.Vs)(e,n),m[1]=(0,c.Vs)(i,n),t=(0,u.oL)(r,m))}if(t){const e=(0,u.bI)(r,t);e<g&&(a=(0,c.lO)(t,n),g=e)}}const e=d();if(e)return e}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){const s=this.getMap().getView().getProjection();let n=t;const r=(0,c.Cs)();r&&(n=n.clone().transform(r,s));const i=(0,g.Bb)(n);r&&i.transform(s,r);const o=i.getCoordinates()[0];for(let t=0,s=o.length-1;t<s;++t)e.push(o.slice(t,t+2))}segmentGeometryCollectionGeometry_(e,t){const s=t.getGeometriesArray();for(let t=0;t<s.length;++t){const n=this.GEOMETRY_SEGMENTERS_[s[t].getType()];n&&n(e,s[t])}}segmentLineStringGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}segmentMultiLineStringGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach(t=>{e.push([t])})}segmentMultiPolygonGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length;t<s;++t){const s=n[t];for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}}}const y=p}}]);